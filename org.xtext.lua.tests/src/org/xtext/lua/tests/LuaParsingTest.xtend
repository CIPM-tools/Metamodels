/*
 * generated by Xtext 2.28.0
 */
package org.xtext.lua.tests

import com.google.inject.Provider
import java.io.ByteArrayOutputStream
import java.nio.file.FileSystems
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.util.ArrayList
import javax.inject.Inject
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import org.xtext.lua.LuaStandaloneSetup
import org.xtext.lua.lua.Chunk

@ExtendWith(InjectionExtension)
@InjectWith(LuaInjectorProvider)
class LuaParsingTest {
	@Inject extension ParseHelper<Chunk>
	@Inject extension Provider<XtextResourceSet>
	@Inject extension ValidationTestHelper

	val luaSnippet = '''
		num = 666
		
		local function foo()
			num = num + 1
		end
		
		foo()
		eq = num == 667
	'''

	/* this is critical, as parsing it using the ParseHelper will create a synthetic
	 * resource, where our stdlib injection scheme does _not_ work.
	 */
	val luaSnippetWithStdLib = '''
		local function foo()
			print("foo bar")
		end
		
		foo()
	'''

	@Test
	def void loadModel() {
		val result = parse(luaSnippet)
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	def void assertEqualsCodeAndParsedPrinted(String orig) {
		val result = parse(orig)
		assertNoIssues(result)

		val outputStream = new ByteArrayOutputStream()
		result.eResource.save(outputStream, #{})
		val parsedAndPrinted = outputStream.toString()

		val expected = orig
		val actual = parsedAndPrinted
		Assertions.assertEquals(expected, actual)
	}

	@Test
	def void testSimpleCode() {
		assertEqualsCodeAndParsedPrinted(luaSnippet)
	}

	@Test
	def void testXMIexport() {
//		Setting the path like this did not work surprisingly: 
//		new StandaloneSetup().platformUri = "./test-data/"
		val injector = new LuaStandaloneSetup().createInjectorAndDoEMFRegistration()
		var XtextResourceSet rs = injector.getInstance(XtextResourceSet)
		var Resource r1 = rs.getResource(URI.createURI("./test-data/foo.lua"), true)
		r1.load(null);
		var Resource r2 = rs.createResource(URI.createURI("./test-data/foo.xmi"));
		r2.getContents().add(r1.getContents().get(0));
		r2.save(null);
	}

	/**
	 * This brings a string into a form where we can compare it to another of the same form
	 * This prevents false positives from whitespace, comment which would otherwise create
	 * differences between the two strings.
	 */
	def String bringIntoCanonicalForm(String luaCode) {
		// strip comments
		var striped = luaCode.replaceAll("(?m)--[^\n]*\n?", "")

		// to leading and trailingwhite space characters
		striped = striped.replaceAll("(?m)^[\t ]*", "")
		striped = striped.replaceAll("(?m)[\t ]*$", "")

		// only one newline between lines
		striped = striped.replaceAll("[\r\n]+", "\n")

		// no newlines in first and last line 
		striped.trim()
	}

	def String bringIntoExtremelyCanonicalForm(String canonicalForm) {
		// spaces my occur in the original file
		// this breaks strings, but that doesn't matter here
		var canonical = canonicalForm.replaceAll("[\t ]+", "")

		// no newlines in first and last line 
		canonical.replaceAll("\n","")
	}

	def boolean checkCaseStudyFile(XtextResourceSet rs, Path srcFile, Path appPath, String name) {
		val uri = URI.createURI(srcFile.toString)
		val res = rs.getResource(uri, true)
		val origString = Files.readString(srcFile)

		val outputStream = new ByteArrayOutputStream()
		res.save(outputStream, #{})
		val parsedAndPrinted = outputStream.toString()

		// strip things like unimportant whitespace, duplicate newlines, etc.
		val origCanonical = bringIntoCanonicalForm(origString)
		val parsedAndPrintedCanonical = bringIntoCanonicalForm(parsedAndPrinted)
		
		// further also strip _all_ newlines and whitespace
		// this definitely breaks the file, but that does not matter for the string comparision
		val origExtremelyCanonical = bringIntoExtremelyCanonicalForm(origCanonical)
		val parsedAndPrintedExtremelyCanonical = bringIntoExtremelyCanonicalForm(parsedAndPrintedCanonical)

		assertNoIssues(res)
		val equivalence = origExtremelyCanonical.equals(parsedAndPrintedExtremelyCanonical)

		// write strings to files if there are differences
		if (!equivalence) {
			val targetDir = Paths.get("./caseStudyEvaluation/").resolve(name).resolve(appPath.relativize(srcFile))
			val plainDir = targetDir.resolve("plain")
			val canonicalDir = targetDir.resolve("canonical")
			val extremelyCanonicalDir = targetDir.resolve("extremely-canonical")
			Files.createDirectories(plainDir)
			Files.createDirectories(canonicalDir)
			Files.createDirectories(extremelyCanonicalDir)
			Files.writeString(plainDir.resolve("orig.lua"), origString)
			Files.writeString(plainDir.resolve("parsedAndPrinted.lua"), parsedAndPrinted)
			Files.writeString(canonicalDir.resolve("orig.lua"), origCanonical)
			Files.writeString(canonicalDir.resolve("parsedAndPrinted.lua"), parsedAndPrintedCanonical)
			Files.writeString(extremelyCanonicalDir.resolve("orig.lua"), origExtremelyCanonical)
			Files.writeString(extremelyCanonicalDir.resolve("parsedAndPrinted.lua"), parsedAndPrintedExtremelyCanonical)
		}

		return equivalence
	}

	def void checkApp(Path appPath, String name) {
		val rs = get()
		val matcher = FileSystems.^default.getPathMatcher("glob:**.lua")

		val equalPaths = new ArrayList<Path>();
		val unequalPaths = new ArrayList<Path>();

		try (val paths = Files.walk(appPath))
			paths.filter[p|matcher.matches(p)].forEach [ path |
				val relPath = appPath.relativize(path)
				if (checkCaseStudyFile(rs, path, appPath, name)) {
					equalPaths.add(relPath)
				} else {
					unequalPaths.add(relPath)
				}
			]
		System.out.printf("Equivalent files: %d %s\n", equalPaths.size, equalPaths)
		System.out.printf("Not equivalent files: %d %s\n", unequalPaths.size, unequalPaths)
		Assertions.assertTrue(unequalPaths.empty, "Files which failed check: " + unequalPaths.toString)
	}

	@Test
	def void testCaseStudy1CodeModelCorrectness() {
		val appPath = Paths.get("../caseStudy1")
		checkApp(appPath, "CaseStudy1")
	}

	@Test
	def void testCaseStudy2CodeModelCorrectness() {
		val appPath = Paths.get(
			"/home/burgey/documents/studium/ma/src/gitlab.sickcn.net/tburglu/color-sorter/ColorInspectionSorter")
		checkApp(appPath, "CaseStudy2")
	}
}
