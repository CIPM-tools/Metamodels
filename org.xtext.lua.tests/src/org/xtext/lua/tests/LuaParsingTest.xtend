/*
 * generated by Xtext 2.28.0
 */
package org.xtext.lua.tests

import com.google.inject.Provider
import java.io.ByteArrayOutputStream
import java.nio.file.FileSystems
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import javax.inject.Inject
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import org.xtext.lua.LuaStandaloneSetup
import org.xtext.lua.lua.Chunk

@ExtendWith(InjectionExtension)
@InjectWith(LuaInjectorProvider)
class LuaParsingTest {
	@Inject extension ParseHelper<Chunk>
	@Inject extension Provider<XtextResourceSet>
	@Inject extension ValidationTestHelper

	val luaSnippet = '''
		num = 666
		
		local function foo()
			num = num + 1
		end
		
		foo()
		eq = num == 667
	'''

	/* this is critical, as parsing it using the ParseHelper will create a synthetic
	 * resource, where our stdlib injection scheme does _not_ work.
	*/
	val luaSnippetWithStdLib = '''
		local function foo()
			print("foo bar")
		end
		
		foo()
	'''

	@Test
	def void loadModel() {
		val result = parse(luaSnippet)
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	def String stripComments(String luaCode) {
		// strip comments
		var striped = luaCode.replaceAll("(?m)--[^\n]*\n?", "")

		// to leading and trailingwhite space characters
		striped = striped.replaceAll("(?m)^[\t ]*", "")
		striped = striped.replaceAll("(?m)[\t ]*$", "")

		// only one newline between lines
		striped = striped.replaceAll("\n+", "\n")
		
		// no newlines in first and last line 
		striped.trim()
	}

	def void assertEqualsCodeAndParsedPrinted(String orig) {
		val result = parse(orig)
		assertNoIssues(result)
		
		val outputStream = new ByteArrayOutputStream()
		result.eResource.save(outputStream, #{})
		val parsedAndPrinted = outputStream.toString()

		val expected = orig
		val actual = parsedAndPrinted
		Assertions.assertEquals(expected, actual)
	}

	@Test
	def void testSimpleCode() {
		assertEqualsCodeAndParsedPrinted(luaSnippet)
	}

	@Test
	def void testXMIexport() {
//		Setting the path like this did not work surprisingly: 
//		new StandaloneSetup().platformUri = "./test-data/"
		val injector = new LuaStandaloneSetup().createInjectorAndDoEMFRegistration()
		var XtextResourceSet rs = injector.getInstance(XtextResourceSet)
		var Resource r1 = rs.getResource(URI.createURI("./test-data/foo.lua"), true)
		r1.load(null);
		var Resource r2 = rs.createResource(URI.createURI("./test-data/foo.xmi"));
		r2.getContents().add(r1.getContents().get(0));
		r2.save(null);
	}
	
	def void checkCaseStudyFile(XtextResourceSet rs, Path srcFile) {
		val uri = URI.createURI(srcFile.toString)
		val res = rs.getResource(uri, true)
		val origString = Files.readString(srcFile)

		val outputStream = new ByteArrayOutputStream()
		res.save(outputStream, #{})
		val parsedAndPrinted = outputStream.toString()
		
		val origWithoutComments = stripComments(origString)
		val parsedAndPrintedWithoutComments = stripComments(parsedAndPrinted)

		assertNoIssues(res)
		Assertions.assertEquals(origWithoutComments, parsedAndPrintedWithoutComments)
	}

	@Test
	def void testCaseStudy1CodeModelCorrectness() {
		val rs = get()
		val appPath = Paths.get("../caseStudy1")
		val matcher = FileSystems.^default.getPathMatcher("glob:**.lua")

		try (val paths = Files.walk(appPath))
			paths.filter[p|matcher.matches(p)]
			.forEach[path|checkCaseStudyFile(rs, path)]

	}
}
