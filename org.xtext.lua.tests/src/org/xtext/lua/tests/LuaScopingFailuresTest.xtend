/*
 * generated by Xtext 2.28.0
 */
package org.xtext.lua.tests

import javax.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import org.xtext.lua.lua.Chunk

@ExtendWith(InjectionExtension)
@InjectWith(LuaInjectorProvider)
class LuaScopingFailuresTest {
	@Inject extension ParseHelper<Chunk>

	val failureSrc = #{
		// no self reference
		'''
			hello = hello
		''',
		// no access to uncalled function
		'''
			local function foo(...)
				local bar = 42
			end
			
			result = bar
		''',
		// Cannot declare a qualified function without declaring the table first
		'''
			function Foo.bar(...)
			end
		'''
	}

	@Disabled("We assume a correct grammar for the evaluation, because finding all errors is very hard")
	@Test
	def void testFailureScoping() {
		val falsePositives = newArrayList
		failureSrc.forEach [
			val result = parse(it)
			val errors = result.eResource.errors
//			ValidationTestHelper.assertIssue(result, Chunk.eClass, "Foo", Severity.INFO)
//			assertIssue(result, result.eClass,)
			if (errors.isEmpty)
				falsePositives.add('''Missing expected errors in:
				«it»
				''')
		]
		Assertions.assertTrue(falsePositives.isEmpty, '''There were false positives:
		«falsePositives.join('\n')»
		''')
	}

}
