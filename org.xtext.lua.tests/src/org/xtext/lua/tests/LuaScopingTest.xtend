/*
 * generated by Xtext 2.28.0
 */
package org.xtext.lua.tests

import javax.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import org.xtext.lua.lua.Chunk
import org.xtext.lua.lua.Expression_Functioncall
import org.xtext.lua.lua.Expression_TableConstructor
import org.xtext.lua.lua.Expression_VariableName
import org.xtext.lua.lua.Field_AddEntryToTable
import org.xtext.lua.lua.Refble
import org.xtext.lua.lua.Referenceable
import org.xtext.lua.lua.Statement_Functioncall
import org.xtext.lua.lua.Statement_Global_Assignment
import org.xtext.lua.lua.Statement_Global_Function_Declaration
import org.xtext.lua.lua.Statement_Local_Assignment
import org.xtext.lua.lua.Statement_Local_Function_Declaration

/*
 * check if a references point to the correct refbles
 */
@ExtendWith(InjectionExtension)
@InjectWith(LuaInjectorProvider)
class LuaScopingTest {
	@Inject extension ParseHelper<Chunk>
	@Inject extension ValidationTestHelper
	
	def Chunk getParsedChunk(String snippet) {
		val chunk = parse(snippet)
		Assertions.assertTrue(chunk.eResource.errors.isEmpty)
		assertNoIssues(chunk)
		chunk
	}

	@Test
	def void testRefFunctionDecl() {
		val snippet = '''
			function foo(...)
			end
			result = foo()
			foo()
		'''
		val parsed = getParsedChunk(snippet)
		Assertions.assertEquals(3, parsed.block.statements.length)

		val foo = parsed.block.statements.get(0) as Statement_Global_Function_Declaration as Refble

		// with assignment
		val hasCall = parsed.block.statements.get(1) as Statement_Global_Assignment
		val fooCall =  hasCall.values.get(0) as Expression_Functioncall
		val fooRef = fooCall.calledFunction
		Assertions.assertEquals(foo, fooRef)


		// without assignment
		val fooCallFlat = parsed.block.statements.get(2) as Statement_Functioncall as Expression_Functioncall
		val fooRefFlat = fooCallFlat.calledFunction
		Assertions.assertEquals(foo, fooRefFlat)
	}
	
	@Test
	def void testRefFunctionDeclLocal() {
		val snippet = '''
			local function foo(...)
			end
			local result = foo()
			foo()
		'''
		val parsed = getParsedChunk(snippet)
		Assertions.assertEquals(3, parsed.block.statements.length)

		val foo = parsed.block.statements.get(0) as Statement_Local_Function_Declaration as Refble

		// with assignment
		val hasCall = parsed.block.statements.get(1) as Statement_Local_Assignment
		val fooCall =  hasCall.values.get(0) as Expression_Functioncall
		val fooRef = fooCall.calledFunction
		Assertions.assertEquals(foo, fooRef)


		// without assignment
		val fooCallFlat = parsed.block.statements.get(2) as Statement_Functioncall as Expression_Functioncall
		val fooRefFlat = fooCallFlat.calledFunction
		Assertions.assertEquals(foo, fooRefFlat)
	}

	@Test
	def void testRefSimpleAssignment() {
		val snippet = '''
			bar = 42
			result = bar
		'''
		val parsed = getParsedChunk(snippet)
		Assertions.assertEquals(2, parsed.block.statements.length)

		val hasBar = parsed.block.statements.get(0) as Statement_Global_Assignment
		val bar = hasBar.dests.get(0) as Referenceable

		val hasRef = parsed.block.statements.get(1) as Statement_Global_Assignment
		val barRef = (hasRef.values.get(0) as Expression_VariableName).ref

		// check if barRef points to bar
		Assertions.assertEquals(bar, barRef)
	}

	/*
	 * check if a reference points to the correct refble
	 */
	@Test
	def void testRefTableAssignment() {
		val snippet = '''
			Foo = {
				bar = 42
			}
			result = Foo.bar
		'''
		val parsed = getParsedChunk(snippet)
		Assertions.assertEquals(2, parsed.block.statements.length)

		val hasBar = parsed.block.statements.get(0) as Statement_Global_Assignment
		val fooList = hasBar.values.get(0) as Expression_TableConstructor
		// this field is refble
		val bar = fooList.fields.get(0) as Field_AddEntryToTable

		val hasRef = parsed.block.statements.get(1) as Statement_Global_Assignment
		val barRef = (hasRef.values.get(0) as Expression_VariableName).ref

		// check if barRef points to bar
		Assertions.assertEquals(bar, barRef)
	}
}